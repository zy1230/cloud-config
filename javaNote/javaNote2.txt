知识点：

1、synchronized	线程,同步

2、java注释：

   单行：//

   多行：/*  ................ */

3、继承:
      在 Java 中，一个类可以由其他类派生。

      如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。

      利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。

      被继承的类称为超类（super class），派生类称为子类（subclass）

4、接口：

      在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。
      
      接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。



----------------------------------------------------------------------------------
◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
----------------------------------------------------------------------------------


1、JAVA类与对象：

       Java：面向对象语言

       对象：类的一个实例，有状态和行为
      
       软件对象的状态就是“属性”，行为通过“方法”体现

       类：类是一个模板，描述一类对象

2、Java语言支持的变量类型有：

           （1）、 类变量：独立于方法之外的变量，用 static 修饰。

           （2）、成员变量（实例变量）：独立于方法之外的变量，不过没有 static 修饰。

成员变量在初定义时，不需要赋值，有默认值0会自动赋予它。

成员变量可以被访问控制符修饰：public private protected friendly(默认访问变量）


（有不同的讲法，你自己看着办吧 ，关于“ 实例变量 ”）


        ◇ public：凡是被public修饰的成员变量，都称为公共变量，它可以被任何类（任何包）所访问。

即允许该变量所属的类中所有方法访问，也允许其他类在外部访问。（不建议使用）

        ◇ private：凡是被private修饰的成员变量，都称为私有变量。

它只允许在本类的内部访问，任何外部类都不能访问它。

        ◇ protected:凡是被protected修饰的变量，都被称为保护变量。

除了允许在本类的内部访问之外，还允许它的子类以及同一个包中的其他类访问。子类是指从该类派生出来的类。

        ◇ friendly:如果在变量前不加任何访问权修饰符，它就具有默认的访问控制特性，也称为friendly变量。

它和保护变量非常像，它只允许在同一个包中的其他类访问，即便是子类，如果和父类不在同一包中，

也不能继承默认变量（这是默认访问变量和保护变量的唯一区别）。

因为它限定了访问权限只能在包中，所以也有人称默认访问权限为包访问权限。

            （3）、局部变量：类的方法中的变量。

 ◇局部变量声明在“方法”、“构造方法”或者“语句块”中；

“构造方法”名字与类名同名，创建对象方可使用，构造方法可有多个，因为参数可以有，可以无，可以多个：

public class H{

   public H(int c){    //构造方法，名字与类名相同

   System.out.println("Kim"+c);

}
   public static void main(String [] args){
  
   H a=new H(1230);//创建对象调用
}

}

会输出：

      Kim1230

 ◇局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；

 ◇访问修饰符不能用于局部变量；

 ◇局部变量只在声明它的方法、构造方法或者语句块中可见；

 ◇局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。



注：

    实例成员变量和静态成员变量


          ◇ 实例成员变量： 所有的对象都是实例成员变量。


● 它们的最大特色是：如果所属的对象没有被创建，它们也就不存在。

如果在类的外部使用它，需要先创建一个对象，

然后通过“对象名.变量名”来访问。

          ◇ 静态成员变量:  即类变量（在成员变量前加上static标识符就可以定义一个静态成员变量。）

相对于实例成员变量，静态成员变量具有以下特点：

● 它被类的所有对象共享，因此又被称为类变量。

● 它不是属于某个具体对象，也不是保存在某个对象的内存区域中，而是保存在类的公共存储单元。

因此，可以在类的对象被创建之前就能使用。

● 它既可以通过“对象名.变量名”方式访问，也可以通过“类名.变量名”的方式访问。它们是完全等价的。

------------------------------------------------------------------------------

3、关于调用方法：

     方法有两种：

             （1）、本类的方法
   
             （2）、外部类的方法

    ◇ 如果本类的方法是静态的（static），可以在其他方法中直接调用。

    ◇ 如果本类的方法不是静态的，调用时需要通过类的实例化进行调用，要创建对象调用。

       类名 对象名 =new 类名（）;此类名为本类名
     
       对象名.方法名();

    ◇ 调用外部的类的方法，通过类的实例化进行调用。

       类名 对象名 =new 类名（）;此类名为外部的类名
     
       对象名.方法名();
     
-------------------------------------------------------------------------------

4、java修饰符：
 
         （1）、 访问修饰符
   
         （2）、 非访问修饰符

     ◇ 访问控制修饰符：Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。

Java 支持 4 种不同的访问权限:

● private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

● default (默认：friendly）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

● protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。

● public : 对所有类可见。使用对象：类、接口、变量、方法

     ◇ 非访问修饰符：

● static 修饰符：用来修饰类方法和类变量。

● final 修饰符：用来修饰类、方法和变量，final 修饰的类不能够被继承，

                 修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

   final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。

被 final 修饰的实例变量必须显式指定初始值。

   final 修饰符通常和 static 修饰符一起使用来创建类常量。

类中的 final 方法可以被子类继承，但是不能被子类修改。
   
   声明 final 方法的主要目的是防止该方法的内容被修改。

● abstract 修饰符：用来创建抽象类和抽象方法。

抽象类：

   抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。

   一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，

否则将出现编译错误。

   抽象类可以包含抽象方法和非抽象方法。

抽象方法：

抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。

抽象方法不能被声明成 final 和 static。

任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。

抽象方法的声明以分号结尾，例如：public abstract sample();。

● synchronized 和 volatile 修饰符；主要用于线程的编程。

关于线程的

稍后再提

------------------------------------------------------------------------------------

5、java运算符：

   Java提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：

   ◇ 算术运算符：+    -    *    /    ++    --

   ++  前缀自增自减法( ++a , --a): 先进行自增或者自减运算，再进行表达式运算。

   --  后缀自增自减法( a++ , a--): 先进行表达式运算，再进行自增或者自减运算

   ◇关系运算符：==   !=   >    <    >=    <=

   ◇位运算符：&   |    ^    ~    <<   >>   >>>

   ◇逻辑运算符:&  |   &&   ||   !

短路逻辑运算符：（ &&   || ）

当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，

其结果就必定是false，这时候就不会再判断第二个操作了。

   ◇赋值运算符：=  +=  -=  *=  /=  

   ◇其他运算符:
             
     条件运算符（?:）

     instanceof 运算符:

该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

例：

String name = "James";

boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
    

------------------------------------------------------------------------------------------

6、Java 循环结构：

Java中有三种主要的循环结构：
                       
                        ◇while 循环：

 while( 布尔表达式 ) {

  //循环内容

}

                        ◇do…while 循环：

对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。

do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。

do {
       
//代码语句

} while(布尔表达式);

                        ◇for 循环：

虽然所有循环结构都可以用 while 或者 do...while表示，

但 Java 提供了另一种语句―――――――for 循环，使一些循环结构变得更加简单。

for循环执行的次数是在执行前就确定的。语法格式如下：

    for(初始化; 布尔表达式; 更新) {
      
      //代码语句

      }

例：

    for(int x = 10; x < 20; x = x+1){

         System.out.print("value of x : " + x );

         System.out.print("\n");
      }


注：

    break 关键字：

break 主要用在循环语句 或者 switch 语句中，用来跳出整个语句块。

break 跳出最里层的循环，并且继续执行该循环下面的语句。

   continue 关键字：

continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。

在 for 循环中，continue 语句使程序立即跳转到更新语句。

在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。

-----------------------------------------------------------------------------------

7、Java 条件语句：
 
   if...else


      ●◇ if 语句的语法如下：

if(布尔表达式)
{
   //如果布尔表达式为true将执行的语句
}

如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 if 语句块后面的代码。


      ●◇ if…else 的用法如下：

if(布尔表达式)
{
   
}else{
  
}

      ●◇if...else if...else 语句用法如下：

if(布尔表达式 1)
{
   
}
else if(布尔表达式 2)

{
  
}
    .................
else 

{
   
}

     ●◇嵌套的 if…else 语句

if(布尔表达式 1)
{
      
   if(布尔表达式 2)
  {
     
   }
}


-------------------------------------------------------------------------------

8、Java switch case 语句

   ●switch case 语句语法格式如下：

 switch(expression)
   {
    case value :
       //语句
       break; 
    case value :
       //语句
       break; 
    //你可以有任意数量的case语句
    default : 
       //语句
       break;
    }

   ● switch 语句中的变量类型可以是： byte、short、int 或者 char。

从 Java SE 7 开始，switch 支持字符串 String 类型了。

   ●  switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，

判断是否继续输出，或是跳出判断。

-----------------------------------------------------------

9、Java Number & Math 类：

   ●◇ Java Number类：

一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。

然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。

为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。

所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。

Number 类属于 java.lang 包。

   ●◇ Java Math 类：

Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。

Number & Math 类方法：

◇ceil()：

返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。

◇floor()：

返回小于等于（<=）给定参数的最大整数 。

◇random()：

返回一个随机数。

◇round()：

它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，

所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。

-------------------------------------------------------------------------------

10、Java Character 类

    Character 类用于对单个字符进行操作。

    Character 类在对象中包装一个基本类型 char 的值

然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。

为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。

Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，

例如：
       Character ch = new Character('a');

下面是Character类的方法：

             toString()：返回字符的字符串形式，字符串的长度仅为1

------------------------------------------------------------------------------------


11、转义字符  “\”

前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。


                  \t     ――――――   在文中该处插入一个tab键

                  \n	 ――――――   在文中该处换行

                  \r	 ――――――   在文中该处插入回车

                  \f	 ――――――   在文中该处插入换页符

                  \'	 ――――――   在文中该处插入单引号

                  \"	 ――――――   在文中该处插入双引号

                  \\	 ――――――   在文中该处插入反斜杠

-----------------------------------------------------------------------

12、●◇ Java String 类：

  字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。

  ◇字符串长度：

用于获取有关对象的信息的方法称为访问器方法。

String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。

  ◇连接字符串：

String 类提供了连接两个字符串的方法：

                             string1.concat(string2);
如：
    "我的名字是 ".concat("Runoob");

更常用的是使用'+'操作符来连接字符串，如：
                                         "Hello," + " runoob" + "!"

   ●◇ Java StringBuffer 和 StringBuilder 类：

   当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。

和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，

并且不产生新的未使用对象。

StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于

StringBuilder 的方法不是线程安全的（不能同步访问）。

StringBuffer 方法：

       replace(int start, int end, String str)：

       使用给定 String 中的字符替换此序列的子字符串中的字符。


--------------------------------------------------------------------------------------

13、Java数组：Java 语言中提供的数组是用来存储固定大小的同类型元素。

    ●◇ 数组声明：
    
            数组类型 [] 数组名(arrayRefVar) 或者 数组类型 数组名[]（不是首选方法）

            dataType[] arrayRefVar  或者  dataType  arrayRefVar[]

例：
    double[] myList;         // 首选的方法
 
或  double myList[];         //  效果相同，但不是首选方法

   创建数组：

            Java语言使用new操作符来创建数组，语法如下： arrayRefVar = new dataType[arraySize];

   数组变量的声明，和创建数组可以用一条语句完成，如下所示：

                                 dataType[] arrayRefVar = new dataType[arraySize];

   还可以使用如下的方式创建数组：

                       dataType[] arrayRefVar = {value0, value1, ..., valuek};

   处理数组：

            数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环

或者 For-Each 循环。

  For-Each 循环：

            JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，

它能在不使用下标的情况下遍历数组。

            语法格式如下：
                         for(type element: array)
                     {
                         System.out.println(element);
                      }

例：
       double[] myList = {1.9, 2.9, 3.4, 3.5};
 
         // 打印所有数组元素
            for (double element: myList) {
                              System.out.println(element);
            }

    ●◇ 多维数组：

                  多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素

都是一个一维数组，例如：
                          String str[][] = new String[3][4];


        例如：
               int a[][] = new int[2][3];
        解析：
               二维数组 a 可以看成一个两行三列的数组。


    ●◇Arrays 类：

                  java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。

    具有以下功能：
                  给数组赋值：通过 fill 方法。
    
                  对数组排序：通过 sort 方法,按升序。

                  比较数组：通过 equals 方法比较数组中元素值是否相等。

                  查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。

   注意：

         调用哪个类的静态方法，要用这个类名来调用。
   例如：
        
         Arrays.fill(数组名，要赋予的数字等等);

------------------------------------------------------------------------------------------

14、日期时间：
 
    java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。

    第一个构造函数使用当前日期和时间来初始化对象。
   
    Date( )

    第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。

    Date(long millisec)

    Date对象创建以后，可以调用一些方法。

    ●◇获取当前日期时间：

    Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间

例如：

           // 初始化 Date 对象

           Date date = new Date();
        
           // 使用 toString() 函数显示日期时间

           System.out.println(date.toString());

-------------------------------------------------------------------------------------

15、Java方法：

     ●◇ System.out.println();

          System 是系统类，out 是标准输出对象，println() 是一个方法。

          这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。
                                                                                       
方法的命名规则：

          1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。

例如：addPerson。

     ●◇ main 方法（主方法）是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。

          main 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，

方法名字是 main,此外带个一个 String[] 类型参数。String[] 表明参数是字符串数组。

     ●◇ 方法的重载：
  
                     相同名字但参数不同的方法，重载的方法必须拥有不同的参数列表。

                     不能仅仅依据修饰符或者返回类型的不同来重载方法。

     ●◇ 变量作用域：

                     变量的范围是程序中该变量可以被引用的部分。

                     方法内定义的变量被称为局部变量。

                     局部变量的作用范围从声明开始，直到包含它的块结束。

                     局部变量必须声明才可以使用。

                     方法的参数范围涵盖整个方法。参数实际上是一个局部变量。

                     for循环的初始化部分声明的变量，其作用范围在整个循环。

     ●◇ 构造方法：

          当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，

但构造方法没有返回值。

          通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。

          不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，

默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；

类改为 private，构造函数也改为 private)。

          一旦你定义了自己的构造方法，默认构造方法就会失效。


-----------------------------------------------------------------------------

16、Scanner类：util包里的类

    下面是创建 Scanner 对象的基本语法：

                                       Scanner s = new Scanner(System.in);

    通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串

     ●◇next() 与 nextLine() 区别

         next():

                1、一定要读取到有效字符后才可以结束输入。

                2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。

                3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。

         next() 不能得到带有空格的字符串。

         nextLine()：

                1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。

                2、可以获得空白。

――――――――――――――――――――――――――――――――――――――――――――

17、java异常处理：

    所有的异常类是从 java.lang.Exception 类继承的子类。

    Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。

    异常类（Exception 类）有两个主要的子类：IOException 类和 RuntimeException 类。

    Java 内置异常类

    Java 语言定义了一些异常类在 java.lang 标准包中。

    在 Java 内置类中，有检查性和非检查性异常。
   
    检查性异常：

             ArrayIndexOutOfBoundsException  

             用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。

             等等

   非检查性异常：

             ClassNotFoundException	
 
             应用程序试图加载类时，找不到相应的类，抛出该异常。

             等等

   ◇◇ 捕获异常：

   使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。

   try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：

       try
      {
        // 程序代码

       }catch(ExceptionName e1)
       
      {
           //Catch 块
       }

    Catch语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。

如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。

    ◇◇ 多重捕获块：

    一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。

    多重捕获块的语法如下所示：

    try{
         // 程序代码
     }catch(异常类型1 异常的变量名1)
    {
       // 程序代码
     }catch(异常类型2 异常的变量名2)
    {
      // 程序代码
     }catch(异常类型2 异常的变量名2)
    {
     // 程序代码
     }

    ◇◇ throws/throw 关键字：

    如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。

throws 关键字放在方法签名的尾部。

   也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。

    ◇◇ finally关键字：

         finally 关键字用来创建在 try 代码块后面执行的代码块。

         无论是否发生异常，finally 代码块中的代码总会被执行。

         finally 代码块出现在 catch 代码块最后，语法如下：
          
   try{
                   // 程序代码
       }catch(异常类型1 异常的变量名1){
                  // 程序代码
       }catch(异常类型2 异常的变量名2){
                  // 程序代码
       }finally{
                  // 程序代码
       }


    ◇◇ 声明自定义异常：

        在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。

        所有异常都必须是 Throwable 的子类。

        如果希望写一个检查性异常类，则需要继承 Exception 类。

        如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。


――――――――――――――――――――――――――――――――――――――――――


翻篇：


                               java面向对象
    
 
  1、java继承:

     继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象

从另一个对象获取属性的过程。

     在Java中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类

继承中最常使用的两个关键字是extends和implements。

     所有Java的类均是由java.lang.Object类继承而来的，所以Object是所有类的祖先类，

而除了Object外，所有类必须有一个父类。

    ◇◇ extends ：

     B是A的子类，而作为子类，B的实例拥有A所有的成员变量，但对于private的成员变量B却没有访问权限，

这保障了A的封装性。通过使用关键字extends，子类可以继承父类的除private属性外所有的属性。

    public class A{ }

    继承A类，用extends（A)

    ◇◇ implements ：

    Implements关键字使用在类继承接口的情况下， 这种情况不能使用关键字extends。

    public interface A{ }

    此时用implement （A）

――――――――――――――――――――――――――――――――――――――――――――

2、重写和重载：

   ◇◇ 重写(Override)：

   重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。
 
   子类能够根据需要实现父类的方法。

注意：

   同一个java文件可有不同的类，只有一个类是有public的，这个类与文件名相同，其余类不加任何修饰符。

只需class 类名，当编译时，如果编译通过，会产生不同的class字节码，只会有一个java文件，但会产生java

文件里的不同的类文件。

   比如：
         我在H.java文件里写了两个类，一个是H，另外一个是J,当编译成功后，会产生两个class文件，一个

是H.class，另外一个是J.class。

         我让H继承J，即H是J的子类，J有一个方法mo()，我在H类中可以重写该方法，但方法名和返回类型还有

参数类型都要保持不变，然后我再创建对象：

                 J a=new J();  a.mo();实现的是J中的mo()
 
                 H b=new H();  b.mo();实现的是H中的重写的mo()
 
                 J c=new H();  c.mo();实现的是H中的重写的mo()

另外：
      声明为final的方法不能被重写。

      声明为static的方法不能被重写，但是能够被再次声明。

      构造方法不能被重写。

      如果不能继承一个方法，则不能重写这个方法。


      Super关键字的使用：

                        当需要在子类中调用父类的被重写方法时，要使用super关键字。

   ◇◇ 重载：

        重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。

        每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。



――――――――――――――――――――――――――――――――――――――――――      
  
3、抽象类：（ 关键字 abstract ）

   ◇◇ 抽象类：

        在面向对象的概念中，所有的对象都是通过类来描绘的，

但是反过来，并不是所有的类都是用来描绘对象的，

如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

   抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

   抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式

和普通类一样。

   ◇◇ 抽象方法：

        如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，

那么你可以在父类中声明该方法为抽象方法。

        Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

        public abstract double computePay();

注意：
      一个抽象类可以没有抽象方法，但有抽象方法的类一定是抽象类。

      任何子类必须重写父类的抽象方法，或者声明自身为抽象类。即如果继承了这个类，则一定要实现这个

抽象方法。

――――――――――――――――――――――――――――――――――――――――――――

4、java 接口：

             接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，

接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

             除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

    接口没有构造方法。

    接口中所有的方法必须是抽象方法。

    接口不能包含成员变量，除了static和final变量。

    接口不是被类继承了，而是要被类实现（implements）：
                       
                                    一个类可以同时实现多个接口。

                                    一个类只能继承一个类，但是能实现多个接口。

    接口支持多重继承：在Java中，类的多重继承是不合法，但接口允许多重继承。
       
                      在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口。

――――――――――――――――――――――――――――――――――――――――――――

5、java多态：

   所谓多态，就是指一个引用（类型）在不同的情况下的多种状态。也可以理解为，

多态是指通过指向父类的指针，来调用在不同子类中实现的方法。

   多态存在的三个必要条件
                           继承、重写、父类引用指向子类对象

比如：
       Parent p = new Child();

       new Child()才是创建了对象，Person p 只是指向子类的一个引用。

   当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，

再去调用子类的同名方法。

例：

   cat类和dog类都是继承Animal类的，即Animal是它们的父类。

   Animal an=new cat();
 
   an.cry();
    
   an=new dog();

   an.cry();

   上面就是一个经典的多态案列，一个引用在不同情况下的多种状态。

   an是一个引用，它通过指向父亲的指针来调用不同子类中实现的方法。


――――――――――――――――――――――――――――――――――――

6、工具类：

    ◇◇ Java API : 

             API：应用程序接口

   Java中的API，就是JDK提供的各种功能的Java类

如：

　

   java.lang 
――――Java语言包(包含String、Math、System等类)，任何类中，该包中的类都会被自动导入。 
　　　　　　

   java.util 
――――包含一些实用的工具类（ 包含 list, calendar, date等类） 

　　　　　　
   java.awt  ――――图形用户界面包。 
　　　　　　

   java.io   ――――
提供多种输入/输出功能的类。

　　　　　　

   java.net 
 ――――提供网络应用功能的类

    ◇◇ object类：

                 1、Object类是所有类的超类， Object是Java语言中唯一一个没有父类的类。

                 2、一个类可以不是Object类的直接子类，但一定是Object类的子类，

Java中的每一个类都是从Object扩展来的。

　　　　         3、在Object类中定义的方法，在所有类中都可以使用。

    ◇◇ 包装类：

                 1、Java编程语言不把基本数据类型看作对象。Java 编程语言提供包装类来将基本数据类型

看作对象。

　　             2、在功能上包装类能够完成数据类型之间（除boolean）的相互转换，尤其是基本数据类型

和String类型的转换。

    ◇◇ 包装类：

         基本数据类型不是对象层次结构的组成部分。有时需要像处理对象一样处理这些基本数据类型，

可通过相应的“包装类”来将其“包装” 。

         基本数据类型       封装类

              int           Integer

              char           Character
 
             double         Double

          等等 （共8种数据类型）

          除了int型和char型的封装类有点不同，其余的数据类型的封装类都是大写字母开头，其余一样

     ◇◇ 字符串与基本数据类型、包装类型转换

           1、基本数据类型转换为包装类：
 
　　　　　　int pInt = 500; 

　　　　　　Integer wInt = new Integer(pInt);

           2、包装类转换为基本数据类型：

　　　　　　包装类通过xxxValue()方法转换为基本数据类型

　　　　　　Integer wInt = new Integer(500); 

　　　　　　int pInt = wInt.intValue();

           3、字符串转换为基本数据类型：

　　　　　　  字符串通过parseXXX(String s)方法转换为基本数据类型

　　　　　　　　String sInt = “500”; 

　　　　　　　　int pInt = Integer.parsetInt(sInt);

      也可以    long p =Long.parseLong(sInt);

           4、包装类转换为字符串

　　　　　　  包装类通过toString()方法转换为字符串

　　　　　　　Integer wInt = new Integer(500); 
　　　　　　　　
              String sInt = wInt.toString();

      ◇◇ 字符串类：

           1、字符串表现形式可以分为两种：“ String ” 和  “ StringBuffer ”。

　　　　 
      
           2、不属于8种基本的数据类型，而是一种引用类型。

　　　　

           3、String对象代表一组不可改变的Unicode字符序列，对它的任何修改实际上又产生一个新的字符串

，String类对象的内容一旦被初始化就不能再改变。

　　　　
 
           4、“ StringBuffer ”对象代表一组可改变的Unicode字符序列。

　　　　

           5、String类是final类型的类。

    （一）、String 对象的创建

　　　　  String类的构造方法 ：

　　　　　　1、初始化一个新创建的 String 对象，它表示一个空字符序列。

　　　　　　　　String 变量名 = new String () ; 

            2、字符串文字常量本身是一个String对象。

            3、连接操作符“+”，可以将其它各种类型的数据转换成字符串，并前后连接成新的字符串

。

　　　　　　　　String str1 = “hello ”; 
　　　　　　　　

                String str2 = “world”; 
　　　　　　　　
         
                String str = str1 + str2; //str为“hello world”；

    （二）、StringBuffer 类

　　　　    StringBuffer类用于内容可以改变的字符串

　　　　    可以使用StringBuffer来对字符串的内容进行动态操作，不会产生额外的对象

　          1、构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符

　　　　　　         StringBuffer 变量名 = new StringBuffer () ;

            2、构造一个不带字符，但具有指定初始容量的字符串缓冲区。

　　　　　　

                     StringBuffer 变量名 = new StringBuffer (int capacity ) ;

　　　　

            3、构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。

　　　　　　

                     StringBuffer 变量名 = new StringBuffer (String value) ;

        == :

　　　　     在比较基本数据类型时，比较的是值

　　　　     在比较引用数据类型时，比较的是地址

        String、StringBuffer、StringBuilder

的区别：　　　　

             String不可变字符序列 
　　　　

             StringBuffer、StringBuilder可变字符序列 
　　　　
 
             StringBuffer线程安全但是效率低，较早引入 
　　　　

             StringBuilder线程不安全但是效率高，较晚引入

       ◇◇ Math 类

　　　　    Math类提供了大量用于数学运算的方法

　　　　    Math类是final类，因此不能从Math类继承

　　　　    Math类中的方法都是static方法，因此不必创建Math类的对象就可以直接使用该类的方法

――――――――――――――――――――――――――――――――――――――――――――
7、java注释：

   关于注释，有三种：

                  单行注释：//

                  多行注释：/*  ――――――  /

                  说明注释：/**――――――*/（文档注释）

   主讲说明注释：

        说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，

并输出到HTML文件中。说明注释，使你更加方便的记录你的程序信息。

       在开始的 /** 之后，第一行或几行是关于类、变量和方法的主要描述。
   
       之后，你可以包含一个或多个各种各样的 @ 标签。每一个 @ 标签必须在一个新行的开始或者在一行的

开始紧跟星号(*).

      多个相同类型的标签应该放成一组。

下面是一个类的说明注释的实例：
            
                /*** 这个类绘制一个条形图

                 * @author runoob  （@author ―― 标识一个类的作者）
      
                 * @version 1.2    （@version ―― 指定类的版本）

                */
javadoc 工具将你 Java 程序的源代码作为输入，输出一些包含你程序注释的HTML文件。

生成注释文档的命令：javadoc 类名.java 

然后会生成一些html文件。




――――――――――――――――――――――――――――――――――――――


8、集合：

   ◇◇ 集合：
              Java中集合类是用来存放对象的

              集合相当于一个容器，里面包容着一组对象 ――――容器类

              其中的每个对象作为集合的一个元素出现

              Java API提供的集合位于java.util包内

              集合框架的类和接口均在java.util包中。

      ◇ Map接口和Collection接口是所有集合框架的父接口

      ◇Collection接口的子接口包括：Set接口和List接口
   
      ◇Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等
   
      ◇Set接口的实现现类主要有：HashSet、TreeSet、LinkedHashSet等

      ◇List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等

1、集合弥补了数组的缺陷，他比数组更灵活更实用，可大大提高软件的开发效率，而且不同的集合可使用与

不同场合。

2、数组和集合的区别：

            ◇数组长度固定，集合长度可以动态改变

            ◇定义数组时必须指定元素类型，集合默认所有元素都是Object
 
            ◇无法直接获取数组中实际元素的个数，集合可以通过size()直接获取元素个数

            ◇集合有多种实现方式和不同的适合场合，而不像数组仅采用分配连续空间方式。

            ◇集合以接口，类的形式存在，具有面向对象的三大特征，提高了软件的开发效率

3、Collection的使用

   ◇ Collection接口是什么？

   Collection接口是可以理解成动态的数组、集合，和数组类似，但不同的是集合可以任意扩充大小

   Collection是最基本的接口，Java SDK提供的类都是继承自Collection的子接口，例如“List”、“Set”。


    ◇ ◇ ◇ ◇ ◇ List接口的使用

          List接口的特点：

                 List接口可以存放任意的数据，且在接口中，内容可以重复

                 List中提供了高效的插入和移除多个元素的方法

                 List常用（实现）子类：

        （1）ArrayList实现类

是一个可改变大小的数组。当更多元素加入到ArrayList时。其大小会动态增长，

内部的元素可以直接通过get和set方法进行访问

。
         
                               List<String> str1 = new ArratList<String>();
 
        （2）LinkedList实现类

是一个双链表，在添加和删除元素时比ArrayList有更好的性能，

但是get和set方面弱于ArrayList。

?

                               List<String> str2 = new LinkedList<String>();

注意：
      List<String> str1 = new ArratList<String>();

      这句语句：

              List是接口，不能直接去创建对象。

              但是它可以通过实现了这个接口的内部类去引用对象。也就是我们通过一个内部类实现了

接口里的抽象方法并且返回一个内部类对象，之后我们通过接口的引用捕获这个对象。

              ”=”号右边先执行，即 new 了一个ArratList对象，这时我们无法对这个对象操作，

所以又声明了一个名为 str1 的引用指向这个对象，这样我们就可以通过操作 str1 来操作对象。

              在这里，对象和对“对象”的引用要分清，这是两个概念。

              实例化一个对象，在java中从本质上来讲是从堆里申请到内存分配给这个对象，一个对象应该

是一个存在内存中的实体，里面存储着属性和方法等。

      那为什么会用一个接口的引用去捕获这个对象?为什么不用类的引用去捕获？ 

              这里存在着向上转型的这样一个知识点
              
              向上转型：

                       在java中接口就是一个完全抽象的类，跟抽象类一样不能产生对象，

但是可以作为对象的引用，可以由其“实现类”向上转型，它就跟超类一样,向上转型了,可以很好的利用接口，

可以调用接口中的所有在实现接口类中的方法，而不能把引用指向接口(或者超类)中没有的方法。
      

   ◇ ◇ ◇ ◇ ◇ Set的使用

          Set接口的特点：

                Set接口可以存放任意的数据，且在接口中，数据不可以重复（注意和List进行区别）

                Set接口常用子类：

             ◇ HashSet
                        Set sets = new HashSet<>();
             ◇ TreeSet
                        Set sets = new TreeSet<>();

          HashSet和TreeSet的区别：

                 HashSet与TreeSet都是间接实现了Set接口，同样拥有add、remove等方法

                 HashSet是无序存放的、而TreeSet实现是有序存放（ASCII顺序存放）

4、Map的使用

  ◇ Map的特点：

       Map接口存放数据是以键值对的形式存放。Map<key,value> map = new HashMap<key,value>();

例如：
         key -> value
 
        "name" -> "尼古拉斯赵四"

         "age" -> "33"

       键（key）的类型要一致，值（value）的类型也要一致。

     Map常用实现类（实现类的方法和List、Set的方法不一样）

     HashMap：

            Map<String,String> maps = new HashMap<String,String>();

            maps.put("name","詹姆斯刘能");

            maps.put("age","24");

5、迭代器iterator的使用（接口）

                  iterator自带常用方法

                  hasNext：如果仍有元素可以迭代，则返回true

                  next：返回迭代下一个元素

                  remove：从迭代器指向的collection中移除迭代器返回的最后一个元素（可选操作）






――――――――――――――――――――――――――――――――――――――――――――――――


















































































































